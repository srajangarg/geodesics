- mesh cleaning
- mesh triangulation
- viewer and reading integration
- update_saddle_boundary
- recompute_min_d


Interval best_first_interval(Point destination, vector<Point> &path)
    {
        if (destination.ptype == Point::EDGE) {
            Edge *e = (Edge *)destination.p;
            auto &intervals = edge_intervals[e];
            double ratio = (destination.pos - e->getEndpoint(0)->getPosition()).length()
                           / e->length();

            for (auto interval : intervals) {
                if ((interval->st / e->length() > ratio)
                    and (interval->end / e->length() < ratio))
                    return *interval;
            }
        } else if (destination.ptype == Point::FACE) {
            Face *f = (Face *)destination.p;
            double distance = std::numeric_limits<double>::infinity();
            Interval min_interval;
            Point next_point(0, 0, 0); // temporarily an undefined point
            for (auto it = f->edges.begin(); it != f->edges.end(); ++it) {
                // pos += (*it)->getPosition();
                auto &intervals = edge_intervals[*it];
                // find the interval which is closest to the destination and source
                for (auto interval : intervals) {
                    if (interval->from == f)
                        continue;

                    // consider only such intervals through which the path can pass
                    // through
                    Vector3 pos = destination.pos;
                    Vector3 pos1 = (*it)->getEndpoint(0)->getPosition();
                    Vector3 pos2 = (*it)->getEndpoint(1)->getPosition();
                    //         pos(source)
                    //       /
                    //     /
                    //(0)pos1--(st,0)------(end,0)---pos2
                    ////////////////////////
                    //------------pos(destination)
                    if ((*it)->getEndpoint(0) > (*it)->getEndpoint(1))
                        swap(pos1, pos2);

                    double dest_x = (pos - pos1).dot((pos2 - pos1).unit());
                    double dest_y = -sqrt((destination.pos - pos1).squaredLength()
                                          - dest_x * dest_x);
                    // pythagoras theoram
                    // get the point where source.pos and dest.pos meet x-axis and
                    // then calculate the miimum distance to source through this interval
                    double axis_x
                        = interval->pos.x()
                          - interval->pos.y() * ((interval->pos.x() - dest_x)
                                                 / (interval->pos.y() - dest_y));

                    double source_dist = interval->ps_d;
                    double ratio;
                    // minimum distance from dest to source through this interval
                    if (axis_x > interval->st and axis_x < interval->end) {
                        source_dist += (Vector2(dest_x, dest_y) - interval->pos).length();
                        ratio = axis_x / (*it)->length();
                    } else if (axis_x < interval->st) {
                        source_dist
                            += ((Vector2(dest_x, dest_y) - Vector2(interval->st, 0.0))
                                    .length()
                                + (interval->pos - Vector2(interval->st, 0.0)).length());
                        ratio = interval->st / (*it)->length();
                    } else {
                        source_dist
                            += ((Vector2(dest_x, dest_y) - Vector2(interval->end, 0.0))
                                    .length()
                                + (interval->pos - Vector2(interval->end, 0.0)).length());
                        ratio = interval->end / (*it)->length();
                    }

                    if (source_dist < distance) {
                        distance = source_dist;
                        min_interval = *interval;
                        next_point = Point(*it, ratio);
                    }
                }
            }

            path.push_back(next_point);
            return min_interval;
        } else if (destination.ptype == Point::VERTEX) {
            Vertex *v = (Vertex *)destination.p;
            double distance = std::numeric_limits<double>::infinity();
            Interval min_interval;
            for (auto it = v->edges.begin(); it != v->edges.end(); ++it) {
                Interval interval;
                double source_dist = interval.ps_d;
                if (v == (*it)->getEndpoint(0)) {
                    interval = *(edge_intervals[*it].front());
                    source_dist += (interval.pos - Vector2(interval.st, 0.0)).length();
                    source_dist += interval.st;
                } else {
                    interval = *(edge_intervals[*it].back());
                    source_dist += (interval.pos - Vector2(interval.end, 0.0)).length();
                    source_dist += ((*it)->length() - interval.end);
                }
                if (source_dist < distance)
                    min_interval = interval;
            }

            return min_interval;
        }
    }